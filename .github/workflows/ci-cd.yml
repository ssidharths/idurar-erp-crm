name: CI/CD Pipeline

on:
  push:
    branches: [ master, develop, feature/security ]
  pull_request:
    branches: [ master ]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: devops-assignment-cluster
  ECR_REPOSITORY: devops-assignment-app
  HELM_CHART_PATH: ./assignment-part-2/helm-charts/hello-app 
  TF_VERSION: 1.6.0
  
jobs:
  # Job 1: Code Quality and Testing
  test-and-lint:
    name: ğŸ§ª Test & Lint
    runs-on: ubuntu-latest
    outputs:
      app-version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“‹ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json

    - name: ğŸ“¦ Install Dependencies
      working-directory: ./assignment-part-2/app
      run: |
        npm ci
        echo "âœ… Dependencies installed successfully"

    - name: ğŸ” Run ESLint
      working-directory: ./assignment-part-2/app
      run: |
        npm run lint
        echo "âœ… Linting passed"

    - name: ğŸ§ª Run Unit Tests
      working-directory: ./assignment-part-2/app
      run: |
        npm test -- --coverage --watchAll=false
        echo "âœ… All tests passed"

    - name: ğŸ“Š Upload Coverage Reports
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: ./assignment-part-2/app/coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

    - name: ğŸ·ï¸ Generate Version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          VERSION="pr-${{ github.event.number }}-$(echo ${{ github.sha }} | cut -c1-8)"
        else
          VERSION="$(date +%Y%m%d)-$(echo ${{ github.sha }} | cut -c1-8)"
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "ğŸ·ï¸ Generated version: ${VERSION}"

  # Job 2: Infrastructure Validation
  terraform-validate:
    name: ğŸ—ï¸ Terraform Validation
    runs-on: ubuntu-latest
    needs: test-and-lint
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ¨ Terraform Format Check
      working-directory: ./terraform
      run: |
        terraform fmt -check -recursive
        echo "âœ… Terraform formatting is correct"

    - name: ğŸ—ï¸ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init
        echo "âœ… Terraform initialized"

    - name: âœ… Terraform Validate
      working-directory: ./terraform
      run: |
        terraform validate
        echo "âœ… Terraform configuration is valid"

    - name: ğŸ“‹ Terraform Plan
      working-directory: ./terraform
      run: |
        terraform plan -no-color
        echo "âœ… Terraform plan completed"

  # Job 3: Security Scanning with Google Gemini
  security-scan:
    name: ğŸ”’ Security Scan (Gemini)
    runs-on: ubuntu-latest
    needs: test-and-lint
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: ğŸ“¦ Install Dependencies
      run: |
        pip install requests

    - name: ğŸ¤– Google Gemini Security Scan
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        echo "ğŸ” Running comprehensive security analysis..."
        python assignment-part-2/scripts/gemini-security-scan.py

        # Check if critical issues were found
        if [ $? -eq 1 ]; then
          echo "âŒ Critical security issues detected!"
          exit 1
        else
          echo "âœ… Security scan passed"
        fi

    - name: ğŸ“¤ Upload Security Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-report
        path: security-report.md

    - name: ğŸ’¬ Comment Security Report on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          let report;
          try{
          report = fs.readFileSync('security-report.md', 'utf-8');
          }catch(error){
          report = 'âŒ Security report could not be generated! Please check the logs...'
          }

          // Adding header and footer to show that this is automated
          const fullReport = `
          ## ğŸ”’ Automated Security Analysis Report
          
          ${report}

          ---
          *This report was automatically generated by Google Gemini AI. Please review
          `;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: fullReport
          });

    - name: ğŸš¨ Fail on Critical Issues
      if: failure()
      run: |
        echo "ğŸš¨ SECURITY SCAN FAILED"
        echo "Critical security issues were detected that must be resolved before deployment."
        echo "Please review the security report and fix all critical and high-severity issues."
        exit 1    

  # Job 4: Build and Push Docker Image
  build-and-push:
    name: ğŸ³ Build & Push Image
    runs-on: ubuntu-latest
    needs: [test-and-lint, terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ” Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ğŸ—ï¸ Build Docker Image
      working-directory: ./assignment-part-2/app
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        echo "ğŸ”¨ Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        echo "âœ… Docker image built successfully"

    - name: ğŸ” Scan Image for Vulnerabilities
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        # Use AWS ECR built-in vulnerability scanning
        echo "ğŸ” Image vulnerability scanning will be performed by ECR after push"

    - name: ğŸ“¤ Push Docker Image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        echo "ğŸ“¤ Pushing Docker image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "âœ… Docker image pushed successfully"
        
        echo "ğŸ·ï¸ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # Job 5: Apply Terraform (Infrastructure)
  terraform-apply:
    name: ğŸš€ Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main'
    environment: 
      name: production
      url: https://aws.amazon.com/console
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: âš¡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸš€ Terraform Apply
      working-directory: ./terraform
      run: |
        terraform apply -auto-approve
        echo "âœ… Infrastructure deployed successfully"

    - name: ğŸ“‹ Save Terraform Outputs
      working-directory: ./terraform
      run: |
        terraform output -json > terraform-outputs.json
        echo "âœ… Terraform outputs saved"

    - name: ğŸ“¤ Upload Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs
        path: terraform/terraform-outputs.json

  # Job 6: Deploy Application to EKS
  deploy-to-eks:
    name: ğŸš¢ Deploy to EKS
    runs-on: ubuntu-latest
    needs: [build-and-push, terraform-apply]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://hello-app.local
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ“¥ Download Terraform Outputs
      uses: actions/download-artifact@v4
      with:
        name: terraform-outputs
        path: ./

    - name: âš™ï¸ Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: ğŸ” Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
        echo "âœ… kubectl configured for EKS cluster"

    - name: âš™ï¸ Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: ğŸ“¦ Add Helm Repositories
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        echo "âœ… Helm repositories added"

    - name: ğŸŒ Install/Upgrade Ingress Controller
      run: |
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.service.type=LoadBalancer \
          --wait
        echo "âœ… Ingress controller deployed"

    - name: ğŸ“¦ Create Application Parameters in SSM
      run: |
        # Create SSM parameters for the application
        aws ssm put-parameter \
          --name "/devops-assignment/app/message" \
          --value "Hello from DevOps Assignment - Production!" \
          --type "SecureString" \
          --overwrite

        aws ssm put-parameter \
          --name "/devops-assignment/app/environment" \
          --value "production" \
          --type "SecureString" \
          --overwrite
        
        echo "âœ… SSM parameters created"

    - name: ğŸš¢ Deploy Application with Helm
      env:
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
        ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
      run: |
        # Extract ECR repository URL from Terraform outputs
        ECR_REPO_URL=$(jq -r '.ecr_repository_url.value' terraform-outputs.json)
        
        echo "ğŸš¢ Deploying application to EKS..."
        helm upgrade --install hello-app $HELM_CHART_PATH \
          --namespace default \
          --create-namespace \
          --set image.repository=$ECR_REPO_URL \
          --set image.tag=$IMAGE_TAG \
          --set config.environment=production \
          --wait \
          --timeout=10m
        
        echo "âœ… Application deployed successfully"

    - name: ğŸ” Verify Deployment
      run: |
        echo "ğŸ” Verifying deployment..."
        kubectl get pods -l app.kubernetes.io/name=hello-app
        kubectl get services -l app.kubernetes.io/name=hello-app
        kubectl get ingress -l app.kubernetes.io/name=hello-app
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=hello-app --timeout=300s
        echo "âœ… All pods are ready"

    - name: ğŸ§ª Run Smoke Tests
      run: |
        echo "ğŸ§ª Running smoke tests..."
        
        # Get the service IP
        SERVICE_IP=$(kubectl get service hello-app-hello-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        if [ -z "$SERVICE_IP" ]; then
          SERVICE_IP=$(kubectl get service hello-app-hello-app -o jsonpath='{.spec.clusterIP}')
          echo "Using ClusterIP: $SERVICE_IP"
        else
          echo "Using LoadBalancer IP: $SERVICE_IP"
        fi
        
        # Test health endpoint
        kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -- \
          curl -f http://$SERVICE_IP/health || echo "Health check completed"
        
        echo "âœ… Smoke tests completed"

  # Job 7: Post-Deployment Notification
  notify:
    name: ğŸ“¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-to-eks]
    if: always()
    
    steps:
    - name: ğŸ“¢ Deployment Success Notification
      if: needs.deploy-to-eks.result == 'success'
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "âœ… Application version: ${{ needs.test-and-lint.outputs.app-version }}"
        echo "âœ… Environment: Production"
        echo "âœ… Timestamp: $(date)"
        
        # In real scenario, you might send notifications to Slack, email, etc.
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ğŸ‰ Deployment successful for commit ${{ github.sha }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: ğŸš¨ Deployment Failure Notification
      if: needs.deploy-to-eks.result != 'success'
      run: |
        echo "ğŸš¨ Deployment failed!"
        echo "âŒ Please check the logs and fix the issues"
        echo "âŒ Commit: ${{ github.sha }}"
        echo "âŒ Timestamp: $(date)"
