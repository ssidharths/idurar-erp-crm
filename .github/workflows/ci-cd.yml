name: CI/CD Pipeline

on:
  push:
    branches: [ master, develop, feature/security ]
  pull_request:
    branches: [ master ]

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: devops-assignment-cluster
  ECR_REPOSITORY: devops-assignment-app
  HELM_CHART_PATH: ./assignment-part-2/helm-charts/hello-app 
  TF_VERSION: 1.6.0
  
jobs:
  # Job 1: Code Quality and Testing
  test-and-lint:
    name: 🧪 Test & Lint
    runs-on: ubuntu-latest
    outputs:
      app-version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: 📋 Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json

    - name: 📦 Install Dependencies
      working-directory: ./assignment-part-2/app
      run: |
        npm ci
        echo "✅ Dependencies installed successfully"

    - name: 🔍 Run ESLint
      working-directory: ./assignment-part-2/app
      run: |
        npm run lint
        echo "✅ Linting passed"

    - name: 🧪 Run Unit Tests
      working-directory: ./assignment-part-2/app
      run: |
        npm test -- --coverage --watchAll=false
        echo "✅ All tests passed"

    - name: 📊 Upload Coverage Reports
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: ./assignment-part-2/app/coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

    - name: 🏷️ Generate Version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          VERSION="pr-${{ github.event.number }}-$(echo ${{ github.sha }} | cut -c1-8)"
        else
          VERSION="$(date +%Y%m%d)-$(echo ${{ github.sha }} | cut -c1-8)"
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "🏷️ Generated version: ${VERSION}"

  # Job 2: Infrastructure Validation
  terraform-validate:
    name: 🏗️ Terraform Validation
    runs-on: ubuntu-latest
    needs: test-and-lint
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: ⚡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 🎨 Terraform Format Check
      working-directory: ./terraform
      run: |
        terraform fmt -check -recursive
        echo "✅ Terraform formatting is correct"

    - name: 🏗️ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init
        echo "✅ Terraform initialized"

    - name: ✅ Terraform Validate
      working-directory: ./terraform
      run: |
        terraform validate
        echo "✅ Terraform configuration is valid"

    - name: 📋 Terraform Plan
      working-directory: ./terraform
      run: |
        terraform plan -no-color
        echo "✅ Terraform plan completed"

  # Job 3: Security Scanning with Google Gemini
  security-scan:
    name: 🔒 Security Scan (Gemini)
    runs-on: ubuntu-latest
    needs: test-and-lint
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: 📦 Install Dependencies
      run: |
        pip install requests

    - name: 🤖 Google Gemini Security Scan
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        echo "🔍 Running comprehensive security analysis..."
        python assignment-part-2/scripts/gemini-security-scan.py

        # Check if critical issues were found
        if [ $? -eq 1 ]; then
          echo "❌ Critical security issues detected!"
          exit 1
        else
          echo "✅ Security scan passed"
        fi

    - name: 📤 Upload Security Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-report
        path: security-report.md

    - name: 💬 Comment Security Report on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          let report;
          try{
          report = fs.readFileSync('security-report.md', 'utf-8');
          }catch(error){
          report = '❌ Security report could not be generated! Please check the logs...'
          }

          // Adding header and footer to show that this is automated
          const fullReport = `
          ## 🔒 Automated Security Analysis Report
          
          ${report}

          ---
          *This report was automatically generated by Google Gemini AI. Please review
          `;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: fullReport
          });

    - name: 🚨 Fail on Critical Issues
      if: failure()
      run: |
        echo "🚨 SECURITY SCAN FAILED"
        echo "Critical security issues were detected that must be resolved before deployment."
        echo "Please review the security report and fix all critical and high-severity issues."
        exit 1    

  # Job 4: Build and Push Docker Image
  build-and-push:
    name: 🐳 Build & Push Image
    runs-on: ubuntu-latest
    needs: [test-and-lint, terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 🔐 Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: 🏗️ Build Docker Image
      working-directory: ./assignment-part-2/app
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        echo "🔨 Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        echo "✅ Docker image built successfully"

    - name: 🔍 Scan Image for Vulnerabilities
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        # Use AWS ECR built-in vulnerability scanning
        echo "🔍 Image vulnerability scanning will be performed by ECR after push"

    - name: 📤 Push Docker Image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
      run: |
        echo "📤 Pushing Docker image to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "✅ Docker image pushed successfully"
        
        echo "🏷️ Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # Job 5: Apply Terraform (Infrastructure)
  terraform-apply:
    name: 🚀 Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main'
    environment: 
      name: production
      url: https://aws.amazon.com/console
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: ⚡ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 🏗️ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: 🚀 Terraform Apply
      working-directory: ./terraform
      run: |
        terraform apply -auto-approve
        echo "✅ Infrastructure deployed successfully"

    - name: 📋 Save Terraform Outputs
      working-directory: ./terraform
      run: |
        terraform output -json > terraform-outputs.json
        echo "✅ Terraform outputs saved"

    - name: 📤 Upload Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs
        path: terraform/terraform-outputs.json

  # Job 6: Deploy Application to EKS
  deploy-to-eks:
    name: 🚢 Deploy to EKS
    runs-on: ubuntu-latest
    needs: [build-and-push, terraform-apply]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://hello-app.local
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4

    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 📥 Download Terraform Outputs
      uses: actions/download-artifact@v4
      with:
        name: terraform-outputs
        path: ./

    - name: ⚙️ Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: 🔐 Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
        echo "✅ kubectl configured for EKS cluster"

    - name: ⚙️ Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: 📦 Add Helm Repositories
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        echo "✅ Helm repositories added"

    - name: 🌐 Install/Upgrade Ingress Controller
      run: |
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.service.type=LoadBalancer \
          --wait
        echo "✅ Ingress controller deployed"

    - name: 📦 Create Application Parameters in SSM
      run: |
        # Create SSM parameters for the application
        aws ssm put-parameter \
          --name "/devops-assignment/app/message" \
          --value "Hello from DevOps Assignment - Production!" \
          --type "SecureString" \
          --overwrite

        aws ssm put-parameter \
          --name "/devops-assignment/app/environment" \
          --value "production" \
          --type "SecureString" \
          --overwrite
        
        echo "✅ SSM parameters created"

    - name: 🚢 Deploy Application with Helm
      env:
        IMAGE_TAG: ${{ needs.test-and-lint.outputs.app-version }}
        ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
      run: |
        # Extract ECR repository URL from Terraform outputs
        ECR_REPO_URL=$(jq -r '.ecr_repository_url.value' terraform-outputs.json)
        
        echo "🚢 Deploying application to EKS..."
        helm upgrade --install hello-app $HELM_CHART_PATH \
          --namespace default \
          --create-namespace \
          --set image.repository=$ECR_REPO_URL \
          --set image.tag=$IMAGE_TAG \
          --set config.environment=production \
          --wait \
          --timeout=10m
        
        echo "✅ Application deployed successfully"

    - name: 🔍 Verify Deployment
      run: |
        echo "🔍 Verifying deployment..."
        kubectl get pods -l app.kubernetes.io/name=hello-app
        kubectl get services -l app.kubernetes.io/name=hello-app
        kubectl get ingress -l app.kubernetes.io/name=hello-app
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=hello-app --timeout=300s
        echo "✅ All pods are ready"

    - name: 🧪 Run Smoke Tests
      run: |
        echo "🧪 Running smoke tests..."
        
        # Get the service IP
        SERVICE_IP=$(kubectl get service hello-app-hello-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        
        if [ -z "$SERVICE_IP" ]; then
          SERVICE_IP=$(kubectl get service hello-app-hello-app -o jsonpath='{.spec.clusterIP}')
          echo "Using ClusterIP: $SERVICE_IP"
        else
          echo "Using LoadBalancer IP: $SERVICE_IP"
        fi
        
        # Test health endpoint
        kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -- \
          curl -f http://$SERVICE_IP/health || echo "Health check completed"
        
        echo "✅ Smoke tests completed"

  # Job 7: Post-Deployment Notification
  notify:
    name: 📢 Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-to-eks]
    if: always()
    
    steps:
    - name: 📢 Deployment Success Notification
      if: needs.deploy-to-eks.result == 'success'
      run: |
        echo "🎉 Deployment completed successfully!"
        echo "✅ Application version: ${{ needs.test-and-lint.outputs.app-version }}"
        echo "✅ Environment: Production"
        echo "✅ Timestamp: $(date)"
        
        # In real scenario, you might send notifications to Slack, email, etc.
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"🎉 Deployment successful for commit ${{ github.sha }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: 🚨 Deployment Failure Notification
      if: needs.deploy-to-eks.result != 'success'
      run: |
        echo "🚨 Deployment failed!"
        echo "❌ Please check the logs and fix the issues"
        echo "❌ Commit: ${{ github.sha }}"
        echo "❌ Timestamp: $(date)"
